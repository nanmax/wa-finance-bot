const moment = require('moment');

class FinanceBot {
    constructor(database, aiService, backupService, scheduledBackupService = null) {
        this.database = database;
        this.aiService = aiService;
        this.backupService = backupService;
        this.scheduledBackupService = scheduledBackupService;
    }

    async processMessage(message, author, contactName = null) {
        try {
            // Check for report commands first
            const reportResponse = await this.handleReportCommands(message, author);
            if (reportResponse) {
                return reportResponse;
            }
            
            // Analyze message with AI
            const analysis = await this.aiService.analyzeFinanceMessage(message);
            
            if (!analysis) {
                return null; // No financial data detected
            }

            // Use contact name if available, otherwise use author
            const displayName = contactName || author || 'Unknown';

            // Save to database
            const savedRecord = await this.database.saveTransaction({
                type: analysis.type, // 'income' atau 'expense'
                amount: analysis.amount,
                description: analysis.description,
                category: analysis.category,
                author: displayName, // Use display name instead of author
                timestamp: new Date(),
                original_message: message
            });

            // Generate response message
            const response = await this.generateResponse(analysis, savedRecord || { author: displayName });
            
            return response;

        } catch (error) {
            console.error('Error processing message:', error);
            return '‚ùå Maaf, terjadi kesalahan dalam memproses pesan Anda.';
        }
    }

    async handleReportCommands(message, author) {
        const lowerMessage = message.toLowerCase().trim();
        
        // Summary report commands
        if (lowerMessage === 'summary' || lowerMessage === 'ringkasan' || lowerMessage === 'laporan') {
            return await this.generateSummaryReport();
        }
        
        // Detailed report commands
        if (lowerMessage === 'detail' || lowerMessage.includes('detail') || lowerMessage.includes('laporan detail')) {
            return await this.generateDetailedReport();
        }
        
        // Custom month report (format: "juni 2025", "januari 2024", dll)
        const customMonth = this.parseMonthYear(message);
        if (customMonth) {
            return await this.generateCustomMonthReport(customMonth.month, customMonth.year);
        }
        
        // Last month report commands (lebih spesifik, harus diletakkan sebelum 'bulan')
        if (lowerMessage.includes('bulan kemarin') || lowerMessage.includes('bulan lalu') || lowerMessage.includes('last month')) {
            return await this.generateLastMonthReport();
        }
        
        // 2 months ago report commands
        if (lowerMessage.includes('2 bulan') || lowerMessage.includes('dua bulan') || lowerMessage.includes('2 months')) {
            return await this.generateTwoMonthsAgoReport();
        }
        
        // 3 months ago report commands
        if (lowerMessage.includes('3 bulan') || lowerMessage.includes('tiga bulan') || lowerMessage.includes('3 months')) {
            return await this.generateThreeMonthsAgoReport();
        }
        
        // 6 months ago report commands
        if (lowerMessage.includes('6 bulan') || lowerMessage.includes('enam bulan') || lowerMessage.includes('6 months')) {
            return await this.generateSixMonthsAgoReport();
        }
        
        // 1 year ago report commands
        if (lowerMessage.includes('1 tahun') || lowerMessage.includes('satu tahun') || lowerMessage.includes('1 year')) {
            return await this.generateOneYearAgoReport();
        }
        
        // Monthly report commands (lebih umum, diletakkan setelah yang spesifik)
        if (lowerMessage.includes('bulan') || lowerMessage.includes('monthly') || lowerMessage.includes('laporan bulan')) {
            return await this.generateMonthlyReport();
        }
        
        // Weekly report commands
        if (lowerMessage.includes('minggu') || lowerMessage.includes('weekly') || lowerMessage.includes('laporan minggu')) {
            return await this.generateWeeklyReport();
        }
        
        // Today's report commands
        if (lowerMessage.includes('hari ini') || lowerMessage.includes('today') || lowerMessage.includes('laporan hari ini')) {
            return await this.generateTodayReport();
        }
        
        // Group management commands
        if (lowerMessage === 'admin' || lowerMessage === 'admin panel' || lowerMessage === 'panel admin') {
            return this.generateAdminPanel();
        }
        
        // Add group command
        if (lowerMessage.startsWith('add group') || lowerMessage.startsWith('tambah group') || lowerMessage.startsWith('daftar group')) {
            return await this.handleAddGroup(message, author);
        }
        
        // Remove group command
        if (lowerMessage.startsWith('remove group') || lowerMessage.startsWith('hapus group') || lowerMessage.startsWith('delete group')) {
            return await this.handleRemoveGroup(message, author);
        }
        
        // List groups command
        if (lowerMessage === 'list groups' || lowerMessage === 'daftar group' || lowerMessage === 'groups' || lowerMessage === 'group list') {
            return await this.handleListGroups();
        }
        
        // AI control commands
        if (lowerMessage === 'ai' || lowerMessage === 'ai control' || lowerMessage === 'control ai' || lowerMessage === 'ai panel') {
            return this.generateAIControlPanel();
        }
        
        // Enable AI command
        if (lowerMessage === 'enable ai' || lowerMessage === 'aktifkan ai' || lowerMessage === 'nyalakan ai' || lowerMessage === 'ai on') {
            return await this.handleEnableAI();
        }
        
        // Disable AI command
        if (lowerMessage === 'disable ai' || lowerMessage === 'nonaktifkan ai' || lowerMessage === 'matikan ai' || lowerMessage === 'ai off') {
            return await this.handleDisableAI();
        }
        
        // Set AI key command
        if (lowerMessage.startsWith('set ai key') || lowerMessage.startsWith('ai key') || lowerMessage.startsWith('set key')) {
            return await this.handleSetAIKey(message);
        }
        
        // Check AI status command
        if (lowerMessage === 'ai status' || lowerMessage === 'status ai' || lowerMessage === 'cek ai' || lowerMessage === 'ai info') {
            return await this.handleAICheckStatus();
        }
        
        // Backup & Restore commands
        if (lowerMessage === 'backup' || lowerMessage === 'buat backup' || lowerMessage === 'backup manual') {
            return await this.handleManualBackup();
        }
        
        if (lowerMessage === 'backup list' || lowerMessage === 'daftar backup' || lowerMessage === 'list backup') {
            return await this.handleBackupList();
        }
        
        if (lowerMessage === 'backup schedule' || lowerMessage === 'jadwal backup' || lowerMessage === 'scheduled backup') {
            return await this.handleBackupSchedule();
        }
        
        if (lowerMessage === 'restore' || lowerMessage === 'restore backup' || lowerMessage === 'pulihkan backup') {
            return await this.handleRestoreBackup();
        }
        
        if (lowerMessage === 'restore confirm' || lowerMessage === 'confirm restore') {
            return await this.handleRestoreConfirm();
        }
        
        if (lowerMessage === 'restore cancel' || lowerMessage === 'cancel restore') {
            return await this.handleRestoreCancel();
        }
        
        // Download backup commands
        if (lowerMessage.startsWith('download backup') || lowerMessage.startsWith('download')) {
            return await this.handleDownloadBackup(message);
        }
        
        // Send backup file commands
        if (lowerMessage.startsWith('send backup') || lowerMessage.startsWith('kirim backup')) {
            return await this.handleSendBackupFile(message);
        }
        
        // Scheduled backup management commands
        if (lowerMessage.startsWith('set backup group') || lowerMessage.startsWith('set group backup')) {
            return await this.handleSetBackupGroup(message);
        }
        
        if (lowerMessage === 'backup group status' || lowerMessage === 'status backup group') {
            return await this.handleBackupGroupStatus();
        }
        
        // Help commands
        if (lowerMessage === 'help' || lowerMessage === 'bantuan' || lowerMessage === 'menu') {
            return this.generateHelpMessage();
        }
        
        return null; // No report command detected
    }

    async generateSummaryReport() {
        try {
            const summary = await this.getSummary();
            const formattedIncome = this.formatCurrency(summary.totalIncome);
            const formattedExpense = this.formatCurrency(summary.totalExpense);
            const formattedBalance = this.formatCurrency(summary.balance);
            
            let response = `üìä *RINGKASAN KEUANGAN*\n\n`;
            response += `üí∞ *Total Pemasukan:* Rp ${formattedIncome}\n`;
            response += `üí∏ *Total Pengeluaran:* Rp ${formattedExpense}\n`;
            response += `üí≥ *Saldo:* Rp ${formattedBalance}\n\n`;
            response += `üìÖ *Periode:* Semua waktu\n`;            
            response += `üìù *Total Transaksi:* ${summary.transactionCount} (${summary.incomeCount} pemasukan, ${summary.expenseCount} pengeluaran)\n\n`;
            response += `üí° *Tips:* Ketik "detail" untuk laporan lengkap`;
            
            return response;
        } catch (error) {
            console.error('Error generating summary report:', error);
            return '‚ùå Maaf, terjadi kesalahan dalam membuat ringkasan.';
        }
    }

    async generateDetailedReport() {
        try {
            const report = await this.getDetailByDate(
                new Date(new Date().getFullYear(), 0, 1).toISOString().split('T')[0], // Start of year
                new Date().toISOString().split('T')[0] // Today
            );
            
            let response = `üìã *LAPORAN DETAIL KEUANGAN*\n\n`;
            
            // Summary section
            response += `üìä *RINGKASAN:*\n`;
            response += `üí∞ Total Pemasukan: Rp ${this.formatCurrency(report.summary.totalIncome)}\n`;
            response += `üí∏ Total Pengeluaran: Rp ${this.formatCurrency(report.summary.totalExpense)}\n`;
            response += `üí≥ Saldo: Rp ${this.formatCurrency(report.summary.totalIncome - report.summary.totalExpense)}\n`;
            response += `üìù Total Transaksi: ${report.summary.transactionCount} (${report.summary.incomeCount} pemasukan, ${report.summary.expenseCount} pengeluaran)\n\n`;
            
            // Income breakdown
            if (Object.keys(report.income.byCategory).length > 0) {
                response += `üí∞ *PEMASUKAN PER KATEGORI:*\n`;
                Object.keys(report.income.byCategory).forEach(category => {
                    const data = report.income.byCategory[category];
                    response += `‚Ä¢ ${category}: Rp ${this.formatCurrency(data.total)} (${data.count} transaksi)\n`;
                });
                response += `\n`;
            }
            
            // Expense breakdown
            if (Object.keys(report.expense.byCategory).length > 0) {
                response += `üí∏ *PENGELUARAN PER KATEGORI:*\n`;
                Object.keys(report.expense.byCategory).forEach(category => {
                    const data = report.expense.byCategory[category];
                    response += `‚Ä¢ ${category}: Rp ${this.formatCurrency(data.total)} (${data.count} transaksi)\n`;
                });
                response += `\n`;
            }
            
            response += `üìÖ *Periode:* ${report.period.startDate} s/d ${report.period.endDate}\n`;
            response += `\n`;
            // Tambahkan daftar transaksi pemasukan
            if (report.income.transactions.length > 0) {
                response += `üü¢ *DAFTAR PEMASUKAN*\n`;
                report.income.transactions.forEach(t => {
                    const tgl = new Date(t.timestamp).toLocaleDateString('id-ID');
                    response += `‚Ä¢ [${tgl}] ${t.description} - Rp ${this.formatCurrency(t.amount)}\n`;
                });
                response += `\n`;
            }
            // Tambahkan daftar transaksi pengeluaran
            if (report.expense.transactions.length > 0) {
                response += `üî¥ *DAFTAR PENGELUARAN*\n`;
                report.expense.transactions.forEach(t => {
                    const tgl = new Date(t.timestamp).toLocaleDateString('id-ID');
                    response += `‚Ä¢ [${tgl}] ${t.description} - Rp ${this.formatCurrency(t.amount)}\n`;
                });
                response += `\n`;
            }
            response += `üí° *Tips:* Ketik "bulan ini" untuk laporan bulanan`;
            return response;
        } catch (error) {
            console.error('Error generating detailed report:', error);
            return '‚ùå Maaf, terjadi kesalahan dalam membuat laporan detail.';
        }
    }

    async generateMonthlyReport() {
        return await this.generatePeriodReport('current_month');
    }

    async generateLastMonthReport() {
        return await this.generatePeriodReport('last_month');
    }

    async generateTwoMonthsAgoReport() {
        return await this.generatePeriodReport('two_months_ago');
    }

    async generateThreeMonthsAgoReport() {
        return await this.generatePeriodReport('three_months_ago');
    }

    async generateSixMonthsAgoReport() {
        return await this.generatePeriodReport('six_months_ago');
    }

    async generateOneYearAgoReport() {
        return await this.generatePeriodReport('one_year_ago');
    }

    async generateWeeklyReport() {
        try {
            const now = new Date();
            // Get current day of week (0 = Sunday, 1 = Monday, etc.)
            const currentDay = now.getDay();
            // Calculate days to subtract to get to Sunday (start of week)
            const daysToSubtract = currentDay;
            
            // Start of current week (Sunday)
            const startOfWeek = new Date(now);
            startOfWeek.setDate(now.getDate() - daysToSubtract);
            startOfWeek.setHours(0, 0, 0, 0);
            
            // End of current week (Saturday)
            const endOfWeek = new Date(startOfWeek);
            endOfWeek.setDate(startOfWeek.getDate() + 6);
            endOfWeek.setHours(23, 59, 59, 999);
            
            console.log(`üìÖ Weekly Report Period: ${startOfWeek.toISOString().split('T')[0]} to ${endOfWeek.toISOString().split('T')[0]}`);
            console.log(`Current date: ${now.toISOString()}`);
            console.log(`Current day: ${currentDay}`);
            console.log(`Days to subtract: ${daysToSubtract}`);
            console.log(`Start of week: ${startOfWeek.toISOString()}`);
            console.log(`End of week: ${endOfWeek.toISOString()}`);
            
            const report = await this.getDetailByDate(
                startOfWeek.toISOString().split('T')[0],
                endOfWeek.toISOString().split('T')[0]
            );
            
            let response = `üìÖ *LAPORAN MINGGU INI*\n\n`;
            
            // Summary section
            response += `üìä *RINGKASAN:*\n`;
            response += `üí∞ Total Pemasukan: Rp ${this.formatCurrency(report.summary.totalIncome)}\n`;
            response += `üí∏ Total Pengeluaran: Rp ${this.formatCurrency(report.summary.totalExpense)}\n`;
            response += `üí≥ Saldo: Rp ${this.formatCurrency(report.summary.totalIncome - report.summary.totalExpense)}\n`;
            response += `üìù Total Transaksi: ${report.summary.transactionCount}\n\n`;
            
            // Check if no transactions this week
            if (report.summary.transactionCount === 0) {
                response += `üìù *STATUS:* Belum ada transaksi minggu ini\n\n`;
                response += `üí° *TIPS:*\n`;
                response += `‚Ä¢ Ketik transaksi keuangan untuk menambah data\n`;
                response += `‚Ä¢ Contoh: "jajan 50000" atau "gaji 5000000"\n`;
                response += `‚Ä¢ Ketik "hari ini" untuk laporan harian\n\n`;
            }
            
            // Daily breakdown (if available)
            if (report.expense.transactions.length > 0) {
                response += `üìÖ *TRANSAKSI TERBARU:*\n`;
                const recentTransactions = report.expense.transactions
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                    .slice(0, 5);
                
                recentTransactions.forEach(transaction => {
                    const date = new Date(transaction.timestamp).toLocaleDateString('id-ID', { 
                        day: 'numeric', 
                        month: 'short' 
                    });
                    response += `‚Ä¢ ${date}: ${transaction.description} - Rp ${this.formatCurrency(transaction.amount)}\n`;
                });
                response += `\n`;
            }
            
            response += `üìÖ *Periode:* ${report.period.startDate} s/d ${report.period.endDate}\n`;
            response += `üí° *Tips:* Ketik "hari ini" untuk laporan harian`;
            
            return response;
        } catch (error) {
            console.error('Error generating weekly report:', error);
            return '‚ùå Maaf, terjadi kesalahan dalam membuat laporan mingguan.';
        }
    }

    async generateTodayReport() {
        try {
            const today = new Date();
            // Use local date instead of UTC to handle timezone properly
            const todayStr = today.getFullYear() + '-' + 
                           String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                           String(today.getDate()).padStart(2, '0');
            
            console.log(`üìÖ Today Report Date: ${todayStr}`);
            console.log(`üìÖ Today Timezone Offset: ${today.getTimezoneOffset()}`);
            console.log(`üìÖ Today Local: ${today.toLocaleDateString('id-ID')}`);
            console.log(`üìÖ Today UTC: ${today.toISOString()}`);
            
            const report = await this.getDetailByDate(todayStr, todayStr);
            
            let response = `üìÖ *LAPORAN HARI INI*\n\n`;
            
            // Summary section
            response += `üìä *RINGKASAN:*\n`;
            response += `üí∞ Total Pemasukan: Rp ${this.formatCurrency(report.summary.totalIncome)}\n`;
            response += `üí∏ Total Pengeluaran: Rp ${this.formatCurrency(report.summary.totalExpense)}\n`;
            response += `üí≥ Saldo: Rp ${this.formatCurrency(report.summary.totalIncome - report.summary.totalExpense)}\n`;
            response += `üìù Total Transaksi: ${report.summary.transactionCount}\n\n`;
            
            // Check if no transactions today
            if (report.summary.transactionCount === 0) {
                response += `üìù *STATUS:* Belum ada transaksi hari ini\n\n`;
                response += `üí° *TIPS:*\n`;
                response += `‚Ä¢ Ketik transaksi keuangan untuk menambah data\n`;
                response += `‚Ä¢ Contoh: "jajan 50000" atau "gaji 5000000"\n`;
                response += `‚Ä¢ Ketik "minggu ini" untuk laporan mingguan\n\n`;
            }
            
            // Today's transactions
            if (report.expense.transactions.length > 0) {
                response += `üìù *TRANSAKSI HARI INI:*\n`;
                report.expense.transactions.forEach(transaction => {
                    response += `‚Ä¢ ${transaction.description} - Rp ${this.formatCurrency(transaction.amount)}\n`;
                });
                response += `\n`;
            }
            
            if (report.income.transactions.length > 0) {
                response += `üí∞ *PEMASUKAN HARI INI:*\n`;
                report.income.transactions.forEach(transaction => {
                    response += `‚Ä¢ ${transaction.description} - Rp ${this.formatCurrency(transaction.amount)}\n`;
                });
                response += `\n`;
            }
            
            response += `üìÖ *Tanggal:* ${todayStr}\n`;
            response += `üí° *Tips:* Ketik "minggu ini" untuk laporan mingguan`;
            
            return response;
        } catch (error) {
            console.error('Error generating today report:', error);
            return '‚ùå Maaf, terjadi kesalahan dalam membuat laporan hari ini.';
        }
    }

    generateHelpMessage() {
        let response = `ü§ñ *FINANCE BOT - MENU BANTUAN*\n\n`;
        response += `üìä *LAPORAN KEUANGAN:*\n`;
        response += `‚Ä¢ "summary" atau "ringkasan" - Ringkasan keuangan\n`;
        response += `‚Ä¢ "detail" atau "laporan detail" - Laporan detail lengkap\n`;
        response += `‚Ä¢ "bulan ini" atau "laporan bulan" - Laporan bulanan\n`;
        response += `‚Ä¢ "bulan kemarin" atau "bulan lalu" - Laporan bulan kemarin\n`;
        response += `‚Ä¢ "2 bulan" atau "dua bulan" - Laporan 2 bulan yang lalu\n`;
        response += `‚Ä¢ "3 bulan" atau "tiga bulan" - Laporan 3 bulan yang lalu\n`;
        response += `‚Ä¢ "6 bulan" atau "enam bulan" - Laporan 6 bulan yang lalu\n`;
        response += `‚Ä¢ "1 tahun" atau "satu tahun" - Laporan 1 tahun yang lalu\n`;
        response += `‚Ä¢ "juni 2025" atau "januari 2024" - Laporan bulan spesifik\n`;
        response += `‚Ä¢ "minggu ini" atau "laporan minggu" - Laporan mingguan\n`;
        response += `‚Ä¢ "hari ini" atau "laporan hari ini" - Laporan harian\n\n`;
        response += `üë• *ADMIN GROUP:*\n`;
        response += `‚Ä¢ "admin" atau "admin panel" - Panel admin\n`;
        response += `‚Ä¢ "add group [group_id]" - Tambah group\n`;
        response += `‚Ä¢ "remove group [group_id]" - Hapus group\n`;
        response += `‚Ä¢ "list groups" - Daftar group yang diizinkan\n\n`;
        response += `ü§ñ *AI CONTROL:*\n`;
        response += `‚Ä¢ "ai" atau "ai control" - Panel kontrol AI\n`;
        response += `‚Ä¢ "enable ai" atau "aktifkan ai" - Nyalakan AI\n`;
        response += `‚Ä¢ "disable ai" atau "matikan ai" - Matikan AI\n`;
        response += `‚Ä¢ "set ai key [key]" - Set API key AI\n`;
        response += `‚Ä¢ "ai status" atau "status ai" - Cek status AI\n\n`;
        response += `üì¶ *BACKUP & RESTORE:*\n`;
        response += `‚Ä¢ "backup" atau "buat backup" - Backup manual\n`;
        response += `‚Ä¢ "backup list" atau "daftar backup" - Daftar backup\n`;
        response += `‚Ä¢ "backup schedule" atau "jadwal backup" - Jadwal otomatis\n`;
        response += `‚Ä¢ "set backup group [group_id] [schedule]" - Set group untuk backup otomatis\n`;
        response += `‚Ä¢ "backup group status" - Cek status backup group\n`;
        response += `‚Ä¢ "download backup [file.zip]" - Download file backup\n`;
        response += `‚Ä¢ "restore" atau "restore backup" - Restore data\n\n`;
        response += `üìù *CARA MENGGUNAKAN:*\n`;
        response += `‚Ä¢ Ketik salah satu command di atas untuk mendapatkan laporan\n`;
        response += `‚Ä¢ Atau ketik transaksi keuangan seperti biasa\n`;
        response += `‚Ä¢ Contoh: "jajan 50000" atau "gaji 5000000"\n`;
        response += `‚Ä¢ Untuk laporan bulan spesifik: "juni 2025", "januari 2024"\n\n`;
        response += `üí° *TIPS:*\n`;
        response += `‚Ä¢ Gunakan "detail" untuk analisis lengkap\n`;
        response += `‚Ä¢ Gunakan "bulan ini" untuk review bulanan\n`;
        response += `‚Ä¢ Gunakan "hari ini" untuk monitoring harian\n`;
        response += `‚Ä¢ Gunakan "admin" untuk mengelola group\n`;
        response += `‚Ä¢ Gunakan "ai" untuk kontrol AI service`;
        
        return response;
    }

    generateAdminPanel() {
        let response = `üîß *ADMIN PANEL - FINANCE BOT*\n\n`;
        response += `üë• *GROUP MANAGEMENT:*\n`;
        response += `‚Ä¢ "add group [group_id]" - Tambah group baru\n`;
        response += `‚Ä¢ "remove group [group_id]" - Hapus group\n`;
        response += `‚Ä¢ "list groups" - Lihat daftar group yang diizinkan\n\n`;
        response += `üìä *LAPORAN KEUANGAN:*\n`;
        response += `‚Ä¢ "summary" - Ringkasan keuangan\n`;
        response += `‚Ä¢ "detail" - Laporan detail lengkap\n`;
        response += `‚Ä¢ "bulan ini" - Laporan bulanan\n`;
        response += `‚Ä¢ "bulan kemarin" - Laporan bulan kemarin\n`;
        response += `‚Ä¢ "2 bulan" - Laporan 2 bulan yang lalu\n`;
        response += `‚Ä¢ "3 bulan" - Laporan 3 bulan yang lalu\n`;
        response += `‚Ä¢ "6 bulan" - Laporan 6 bulan yang lalu\n`;
        response += `‚Ä¢ "1 tahun" - Laporan 1 tahun yang lalu\n`;
        response += `‚Ä¢ "minggu ini" - Laporan mingguan\n`;
        response += `‚Ä¢ "hari ini" - Laporan harian\n\n`;
        response += `üìù *CARA MENGGUNAKAN:*\n`;
        response += `‚Ä¢ Ketik command sesuai kebutuhan\n`;
        response += `‚Ä¢ Contoh: "add group 123456789@g.us"\n`;
        response += `‚Ä¢ Atau ketik transaksi keuangan seperti biasa\n\n`;
        response += `üí° *TIPS:*\n`;
        response += `‚Ä¢ Group ID format: [number]@g.us\n`;
        response += `‚Ä¢ Hanya group yang didaftarkan yang bisa menggunakan bot\n`;
        response += `‚Ä¢ Ketik "help" untuk menu lengkap`;
        
        return response;
    }

    async handleAddGroup(message, author) {
        try {
            // Extract group ID from message
            const parts = message.split(' ');
            let groupId = null;
            
            // Find group ID in the message
            for (let i = 0; i < parts.length; i++) {
                if (parts[i].includes('@g.us')) {
                    groupId = parts[i];
                    break;
                }
            }
            
            if (!groupId) {
                return `‚ùå *ERROR:* Group ID tidak ditemukan!\n\n`;
                response += `üìù *CARA PENGGUNAAN:*\n`;
                response += `‚Ä¢ Ketik: "add group [group_id]"\n`;
                response += `‚Ä¢ Contoh: "add group 123456789@g.us"\n\n`;
                response += `üí° *TIPS:*\n`;
                response += `‚Ä¢ Group ID harus berformat: [number]@g.us\n`;
                response += `‚Ä¢ Dapatkan Group ID dari group WhatsApp\n`;
                response += `‚Ä¢ Ketik "admin" untuk panel admin`;
            }
            
            // Validate group ID format
            if (!groupId.match(/^\d+@g\.us$/)) {
                return `‚ùå *ERROR:* Format Group ID tidak valid!\n\n`;
                response += `üìù *FORMAT YANG BENAR:*\n`;
                response += `‚Ä¢ Contoh: 123456789@g.us\n`;
                response += `‚Ä¢ Harus berakhir dengan @g.us\n`;
                response += `‚Ä¢ Hanya angka sebelum @g.us`;
            }
            
            // Check if group already exists
            const config = await this.database.loadConfig();
            if (config.allowedGroups && config.allowedGroups.includes(groupId)) {
                return `‚ö†Ô∏è *INFO:* Group ${groupId} sudah terdaftar!\n\n`;
                response += `üìù *STATUS:* Group sudah diizinkan\n`;
                response += `üí° *TIPS:* Ketik "list groups" untuk melihat daftar lengkap`;
            }
            
            // Add group to allowed list
            if (!config.allowedGroups) {
                config.allowedGroups = [];
            }
            config.allowedGroups.push(groupId);
            await this.database.saveConfig(config);
            
            let response = `‚úÖ *SUCCESS:* Group berhasil ditambahkan!\n\n`;
            response += `üìù *DETAILS:*\n`;
            response += `‚Ä¢ Group ID: ${groupId}\n`;
            response += `‚Ä¢ Status: Diizinkan\n`;
            response += `‚Ä¢ Total Groups: ${config.allowedGroups.length}\n\n`;
            response += `üí° *TIPS:*\n`;
            response += `‚Ä¢ Group sekarang bisa menggunakan bot\n`;
            response += `‚Ä¢ Ketik "list groups" untuk melihat daftar\n`;
            response += `‚Ä¢ Ketik "admin" untuk panel admin`;
            
            return response;
            
        } catch (error) {
            console.error('Error adding group:', error);
            return '‚ùå Maaf, terjadi kesalahan dalam menambahkan group.';
        }
    }

    async handleRemoveGroup(message, author) {
        try {
            // Extract group ID from message
            const parts = message.split(' ');
            let groupId = null;
            
            // Find group ID in the message
            for (let i = 0; i < parts.length; i++) {
                if (parts[i].includes('@g.us')) {
                    groupId = parts[i];
                    break;
                }
            }
            
            if (!groupId) {
                let response = `‚ùå *ERROR:* Group ID tidak ditemukan!\n\n`;
                response += `üìù *CARA PENGGUNAAN:*\n`;
                response += `‚Ä¢ Ketik: "remove group [group_id]"\n`;
                response += `‚Ä¢ Contoh: "remove group 123456789@g.us"\n\n`;
                response += `üí° *TIPS:*\n`;
                response += `‚Ä¢ Group ID harus berformat: [number]@g.us\n`;
                response += `‚Ä¢ Ketik "list groups" untuk melihat daftar\n`;
                response += `‚Ä¢ Ketik "admin" untuk panel admin`;
                return response;
            }
            
            // Validate group ID format
            if (!groupId.match(/^\d+@g\.us$/)) {
                let response = `‚ùå *ERROR:* Format Group ID tidak valid!\n\n`;
                response += `üìù *FORMAT YANG BENAR:*\n`;
                response += `‚Ä¢ Contoh: 123456789@g.us\n`;
                response += `‚Ä¢ Harus berakhir dengan @g.us\n`;
                response += `‚Ä¢ Hanya angka sebelum @g.us`;
                return response;
            }
            
            // Check if group exists
            const config = await this.database.loadConfig();
            if (!config.allowedGroups || !config.allowedGroups.includes(groupId)) {
                let response = `‚ö†Ô∏è *INFO:* Group ${groupId} tidak ditemukan!\n\n`;
                response += `üìù *STATUS:* Group tidak terdaftar\n`;
                response += `üí° *TIPS:* Ketik "list groups" untuk melihat daftar lengkap`;
                return response;
            }
            
            // Remove group from allowed list
            config.allowedGroups = config.allowedGroups.filter(id => id !== groupId);
            await this.database.saveConfig(config);
            
            let response = `‚úÖ *SUCCESS:* Group berhasil dihapus!\n\n`;
            response += `üìù *DETAILS:*\n`;
            response += `‚Ä¢ Group ID: ${groupId}\n`;
            response += `‚Ä¢ Status: Dihapus\n`;
            response += `‚Ä¢ Total Groups: ${config.allowedGroups.length}\n\n`;
            response += `üí° *TIPS:*\n`;
            response += `‚Ä¢ Group tidak bisa menggunakan bot lagi\n`;
            response += `‚Ä¢ Ketik "list groups" untuk melihat daftar\n`;
            response += `‚Ä¢ Ketik "admin" untuk panel admin`;
            
            return response;
            
        } catch (error) {
            console.error('Error removing group:', error);
            return '‚ùå Maaf, terjadi kesalahan dalam menghapus group.';
        }
    }

    async handleListGroups() {
        try {
            const config = await this.database.loadConfig();
            const allowedGroups = config.allowedGroups || [];
            
            let response = `üìã *DAFTAR GROUP YANG DIIZINKAN*\n\n`;
            
            if (allowedGroups.length === 0) {
                response += `üìù *STATUS:* Belum ada group yang didaftarkan\n\n`;
                response += `üí° *TIPS:*\n`;
                response += `‚Ä¢ Ketik "add group [group_id]" untuk menambah group\n`;
                response += `‚Ä¢ Contoh: "add group 123456789@g.us"\n`;
                response += `‚Ä¢ Ketik "admin" untuk panel admin`;
            } else {
                response += `üìä *SUMMARY:*\n`;
                response += `‚Ä¢ Total Groups: ${allowedGroups.length}\n`;
                response += `‚Ä¢ Status: ${allowedGroups.length} group diizinkan\n\n`;
                
                response += `üìù *DAFTAR GROUP:*\n`;
                allowedGroups.forEach((groupId, index) => {
                    response += `${index + 1}. ${groupId}\n`;
                });
                
                response += `\nüí° *TIPS:*\n`;
                response += `‚Ä¢ Ketik "remove group [group_id]" untuk menghapus\n`;
                response += `‚Ä¢ Ketik "admin" untuk panel admin`;
            }
            
            return response;
            
        } catch (error) {
            console.error('Error listing groups:', error);
            return '‚ùå Maaf, terjadi kesalahan dalam menampilkan daftar group.';
        }
    }

    async generateResponse(analysis, savedRecord) {
        const emoji = analysis.type === 'income' ? 'üí∞' : 'üí∏';
        const typeText = analysis.type === 'income' ? 'Pemasukan' : 'Pengeluaran';
        const amount = this.formatCurrency(analysis.amount);
        const date = moment().format('DD/MM/YYYY HH:mm');
        
        console.log(`üìù Response Debug:`);
        console.log(`  - Saved record author: ${savedRecord.author}`);
        console.log(`  - Analysis:`, analysis);
        
        let response = `${emoji} *${typeText} Tercatat!*\n\n`;
        response += `üìä *Detail Transaksi:*\n`;
        response += `‚Ä¢ Jumlah: Rp ${amount}\n`;
        response += `‚Ä¢ Kategori: ${analysis.category}\n`;
        response += `‚Ä¢ Deskripsi: ${analysis.description}\n`;
        response += `‚Ä¢ Tanggal: ${date}\n`;
        response += `‚Ä¢ Oleh: ${savedRecord.author}\n\n`;

        // Add summary
        const summary = await this.getSummary();
        response += `üìà *Ringkasan Keuangan:*\n`;
        response += `‚Ä¢ Total Pemasukan: Rp ${this.formatCurrency(summary.totalIncome)}\n`;
        response += `‚Ä¢ Total Pengeluaran: Rp ${this.formatCurrency(summary.totalExpense)}\n`;
        response += `‚Ä¢ Saldo: Rp ${this.formatCurrency(summary.balance)}\n`;

        return response;
    }

    async getSummary() {
        try {
            const transactions = await this.database.getTransactions();
            console.log("üîç Transactions:", transactions);
            const incomeTransactions = transactions.filter(t => t.type === 'income');
            const expenseTransactions = transactions.filter(t => t.type === 'expense');

            const summary = transactions.reduce((acc, transaction) => {
                if (transaction.type === 'income') {
                    acc.totalIncome += transaction.amount;
                } else {
                    acc.totalExpense += transaction.amount;
                }
                return acc;
            }, { totalIncome: 0, totalExpense: 0 });

            summary.balance = summary.totalIncome - summary.totalExpense;
            summary.incomeCount = incomeTransactions.length;
            summary.expenseCount = expenseTransactions.length;  
            summary.transactionCount = incomeTransactions.length + expenseTransactions.length;
            console.log("üîç Summary:", summary);
            return summary;
        } catch (error) {
            console.error('Error getting summary:', error);
            return { totalIncome: 0, totalExpense: 0, balance: 0 };
        }
    }

    async getSummaryByDate(startDate, endDate) {
        try {
            const transactions = await this.database.getTransactions();
            
            // Filter transactions by date range with proper time boundaries
            const filteredTransactions = transactions.filter(transaction => {
                const transactionDate = new Date(transaction.timestamp);
                
                // Create start and end dates in local timezone
                const startDateLocal = new Date(startDate + 'T00:00:00');
                const endDateLocal = new Date(endDate + 'T23:59:59.999');
                
                // Compare dates in local timezone
                const transactionDateLocal = new Date(transactionDate.getFullYear(), transactionDate.getMonth(), transactionDate.getDate());
                const startDateLocalOnly = new Date(startDateLocal.getFullYear(), startDateLocal.getMonth(), startDateLocal.getDate());
                const endDateLocalOnly = new Date(endDateLocal.getFullYear(), endDateLocal.getMonth(), endDateLocal.getDate());
                
                console.log(`üîç Summary filtering: ${transactionDate.toISOString()} (${transactionDateLocal.toISOString()}) between ${startDateLocalOnly.toISOString()} and ${endDateLocalOnly.toISOString()}`);
                
                return transactionDateLocal >= startDateLocalOnly && transactionDateLocal <= endDateLocalOnly;
            });

            const summary = filteredTransactions.reduce((acc, transaction) => {
                if (transaction.type === 'income') {
                    acc.totalIncome += transaction.amount;
                } else {
                    acc.totalExpense += transaction.amount;
                }
                return acc;
            }, { totalIncome: 0, totalExpense: 0 });

            summary.balance = summary.totalIncome - summary.totalExpense;
            summary.startDate = startDate;
            summary.endDate = endDate;
            summary.transactionCount = filteredTransactions.length;
            
            return summary;
        } catch (error) {
            console.error('Error getting summary by date:', error);
            return { totalIncome: 0, totalExpense: 0, balance: 0, startDate, endDate, transactionCount: 0 };
        }
    }

    async getDetailByDate(startDate, endDate) {
        try {
            const transactions = await this.database.getTransactions();
            
            // Filter transactions by date range with proper time boundaries
            const filteredTransactions = transactions.filter(transaction => {
                const transactionDate = new Date(transaction.timestamp);
                
                // Create start and end dates in local timezone
                const startDateLocal = new Date(startDate + 'T00:00:00');
                const endDateLocal = new Date(endDate + 'T23:59:59.999');
                
                // Compare dates in local timezone
                const transactionDateLocal = new Date(transactionDate.getFullYear(), transactionDate.getMonth(), transactionDate.getDate());
                const startDateLocalOnly = new Date(startDateLocal.getFullYear(), startDateLocal.getMonth(), startDateLocal.getDate());
                const endDateLocalOnly = new Date(endDateLocal.getFullYear(), endDateLocal.getMonth(), endDateLocal.getDate());
                
                console.log(`üîç Filtering: ${transactionDate.toISOString()} (${transactionDateLocal.toISOString()}) between ${startDateLocalOnly.toISOString()} and ${endDateLocalOnly.toISOString()}`);
                
                return transactionDateLocal >= startDateLocalOnly && transactionDateLocal <= endDateLocalOnly;
            });

            // Group by type (income/expense)
            const incomeTransactions = filteredTransactions.filter(t => t.type === 'income');
            const expenseTransactions = filteredTransactions.filter(t => t.type === 'expense');

            // Group by category
            const incomeByCategory = this.groupByCategory(incomeTransactions);
            const expenseByCategory = this.groupByCategory(expenseTransactions);

            return {
                period: {
                    startDate: startDate,
                    endDate: endDate,
                    totalDays: Math.ceil((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24)) + 1
                },
                summary: {
                    totalIncome: incomeTransactions.reduce((sum, t) => sum + t.amount, 0),
                    totalExpense: expenseTransactions.reduce((sum, t) => sum + t.amount, 0),
                    transactionCount: incomeTransactions.length + expenseTransactions.length,
                    incomeCount: incomeTransactions.length,
                    expenseCount: expenseTransactions.length
                },
                income: {
                    transactions: incomeTransactions,
                    byCategory: incomeByCategory
                },
                expense: {
                    transactions: expenseTransactions,
                    byCategory: expenseByCategory
                }
            };
        } catch (error) {
            console.error('Error getting detail by date:', error);
            return {
                period: { startDate, endDate, totalDays: 0 },
                summary: { totalIncome: 0, totalExpense: 0, transactionCount: 0, incomeCount: 0, expenseCount: 0 },
                income: { transactions: [], byCategory: {} },
                expense: { transactions: [], byCategory: {} }
            };
        }
    }

    groupByCategory(transactions) {
        return transactions.reduce((acc, transaction) => {
            const category = transaction.category || 'Uncategorized';
            if (!acc[category]) {
                acc[category] = {
                    total: 0,
                    count: 0,
                    transactions: []
                };
            }
            acc[category].total += transaction.amount;
            acc[category].count += 1;
            acc[category].transactions.push(transaction);
            return acc;
        }, {});
    }

    formatCurrency(amount) {
        return new Intl.NumberFormat('id-ID').format(amount);
    }

    // AI Control Methods
    generateAIControlPanel() {
        let response = `ü§ñ *AI CONTROL PANEL - FINANCE BOT*\n\n`;
        response += `üîß *KONTROL AI SERVICE:*\n`;
        response += `‚Ä¢ "enable ai" atau "aktifkan ai" - Nyalakan AI service\n`;
        response += `‚Ä¢ "disable ai" atau "matikan ai" - Matikan AI service\n`;
        response += `‚Ä¢ "ai status" atau "status ai" - Cek status AI\n\n`;
        response += `üîë *API KEY MANAGEMENT:*\n`;
        response += `‚Ä¢ "set ai key [your_api_key]" - Set OpenAI API key\n`;
        response += `‚Ä¢ Contoh: "set ai key sk-1234567890abcdef"\n\n`;
        response += `üìä *STATUS AI:*\n`;
        response += `‚Ä¢ AI akan menggunakan OpenAI untuk analisis cerdas\n`;
        response += `‚Ä¢ Jika AI dimatikan, akan menggunakan pattern matching\n`;
        response += `‚Ä¢ Pattern matching tetap berfungsi sebagai fallback\n\n`;
        response += `üí° *TIPS:*\n`;
        response += `‚Ä¢ Pastikan API key valid untuk menggunakan AI\n`;
        response += `‚Ä¢ AI memberikan analisis yang lebih akurat\n`;
        response += `‚Ä¢ Pattern matching sebagai backup jika AI error\n`;
        response += `‚Ä¢ Ketik "ai status" untuk cek konfigurasi`;
        
        return response;
    }

    async handleEnableAI() {
        try {
            // Enable AI service
            this.aiService.enableAI();
            
            let response = `‚úÖ *AI SERVICE AKTIF*\n\n`;
            response += `ü§ñ AI service telah diaktifkan\n`;
            response += `üìä Bot akan menggunakan OpenAI untuk analisis\n`;
            response += `üîç Pattern matching tetap sebagai fallback\n\n`;
            response += `üí° *Tips:*\n`;
            response += `‚Ä¢ Pastikan API key sudah diset\n`;
            response += `‚Ä¢ Ketik "ai status" untuk cek konfigurasi\n`;
            response += `‚Ä¢ Ketik "set ai key [key]" jika belum ada key`;
            
            return response;
        } catch (error) {
            console.error('Error enabling AI:', error);
            return '‚ùå Maaf, terjadi kesalahan saat mengaktifkan AI service.';
        }
    }

    async handleDisableAI() {
        try {
            // Disable AI service
            this.aiService.disableAI();
            
            let response = `üîÑ *AI SERVICE DIMATIKAN*\n\n`;
            response += `ü§ñ AI service telah dimatikan\n`;
            response += `üìä Bot akan menggunakan pattern matching\n`;
            response += `üîç Pattern matching tetap berfungsi dengan baik\n\n`;
            response += `üí° *TIPS:*\n`;
            response += `‚Ä¢ Pattern matching mendukung banyak format\n`;
            response += `‚Ä¢ Tetap bisa menganalisis transaksi keuangan\n`;
            response += `‚Ä¢ Ketik "enable ai" untuk mengaktifkan kembali`;
            
            return response;
        } catch (error) {
            console.error('Error disabling AI:', error);
            return '‚ùå Maaf, terjadi kesalahan saat mematikan AI service.';
        }
    }

    async handleSetAIKey(message) {
        try {
            // Extract API key from message
            const keyMatch = message.match(/set ai key (.+)/i) || 
                           message.match(/ai key (.+)/i) || 
                           message.match(/set key (.+)/i);
            
            if (!keyMatch || !keyMatch[1]) {
                return `‚ùå *FORMAT SALAH*\n\n`;
                response += `üìù *Format yang benar:*\n`;
                response += `‚Ä¢ "set ai key [your_api_key]"\n`;
                response += `‚Ä¢ "ai key [your_api_key]"\n`;
                response += `‚Ä¢ "set key [your_api_key]"\n\n`;
                response += `üí° *Contoh:*\n`;
                response += `‚Ä¢ "set ai key sk-1234567890abcdef"\n`;
                response += `‚Ä¢ "ai key sk-abcdef1234567890"\n\n`;
                response += `üîë *Cara mendapatkan API key:*\n`;
                response += `‚Ä¢ Kunjungi https://platform.openai.com\n`;
                response += `‚Ä¢ Buat account atau login\n`;
                response += `‚Ä¢ Buka menu API Keys\n`;
                response += `‚Ä¢ Create new secret key`;
            }
            
            const apiKey = keyMatch[1].trim();
            
            // Validate API key format (basic validation)
            if (!apiKey.startsWith('sk-') || apiKey.length < 20) {
                return `‚ùå *API KEY TIDAK VALID*\n\n`;
                response += `üîë *Format API key yang benar:*\n`;
                response += `‚Ä¢ Harus dimulai dengan "sk-"\n`;
                response += `‚Ä¢ Minimal 20 karakter\n`;
                response += `‚Ä¢ Contoh: sk-1234567890abcdef\n\n`;
                response += `üí° *Tips:*\n`;
                response += `‚Ä¢ Pastikan copy API key dengan benar\n`;
                response += `‚Ä¢ Jangan ada spasi di awal atau akhir\n`;
                response += `‚Ä¢ Ketik "ai status" untuk cek key yang tersimpan`;
            }
            
            // Set API key
            this.aiService.setAPIKey(apiKey);
            
            let response = `‚úÖ *API KEY BERHASIL DISET*\n\n`;
            response += `üîë API key telah disimpan\n`;
            response += `ü§ñ AI service siap digunakan\n`;
            response += `üìä Bot akan menggunakan OpenAI untuk analisis\n\n`;
            response += `üí° *Tips:*\n`;
            response += `‚Ä¢ Ketik "enable ai" untuk mengaktifkan AI\n`;
            response += `‚Ä¢ Ketik "ai status" untuk cek konfigurasi\n`;
            response += `‚Ä¢ Ketik "disable ai" jika ingin matikan AI`;
            
            return response;
        } catch (error) {
            console.error('Error setting AI key:', error);
            return '‚ùå Maaf, terjadi kesalahan saat menyimpan API key.';
        }
    }

    async handleAICheckStatus() {
        try {
            const status = this.aiService.getStatus();
            
            let response = `ü§ñ *AI SERVICE STATUS*\n\n`;
            response += `üìä *Status AI:* ${status.isEnabled ? 'üü¢ AKTIF' : 'üî¥ NONAKTIF'}\n`;
            response += `üîë *API Key:* ${status.hasAPIKey ? '‚úÖ TERSEDIA' : '‚ùå BELUM DISET'}\n`;
            response += `üîç *Pattern Matching:* ‚úÖ SELALU AKTIF\n\n`;
            
            if (status.isEnabled && status.hasAPIKey) {
                response += `‚úÖ *AI SERVICE SIAP*\n`;
                response += `‚Ä¢ OpenAI akan digunakan untuk analisis\n`;
                response += `‚Ä¢ Pattern matching sebagai fallback\n`;
            } else if (status.hasAPIKey && !status.isEnabled) {
                response += `üîÑ *AI TERSEDIA TAPI DIMATIKAN*\n`;
                response += `‚Ä¢ API key sudah diset\n`;
                response += `‚Ä¢ Ketik "enable ai" untuk mengaktifkan\n`;
            } else if (!status.hasAPIKey) {
                response += `üîë *API KEY BELUM DISET*\n`;
                response += `‚Ä¢ Ketik "set ai key [key]" untuk set API key\n`;
                response += `‚Ä¢ Pattern matching tetap berfungsi\n`;
            }
            
            response += `\nüí° *Tips:*\n`;
            response += `‚Ä¢ Pattern matching selalu aktif sebagai backup\n`;
            response += `‚Ä¢ AI memberikan analisis yang lebih akurat\n`;
            response += `‚Ä¢ Ketik "ai" untuk menu kontrol AI`;
            
            return response;
        } catch (error) {
            console.error('Error checking AI status:', error);
            return '‚ùå Maaf, terjadi kesalahan saat mengecek status AI.';
        }
    }

    // Backup & Restore Methods
    async handleManualBackup() {
        try {
            console.log('üîÑ Creating manual backup...');
            
            const backupResult = await this.backupService.createBackup();
            
            if (!backupResult.success) {
                return `‚ùå *BACKUP GAGAL*\n\nError: ${backupResult.error}`;
            }

            const metadata = backupResult.metadata;
            let response = `‚úÖ *BACKUP BERHASIL DIBUAT*\n\n`;
            response += `üì¶ *File:* ${backupResult.fileName}\n`;
            response += `üìÖ *Tanggal:* ${new Date().toLocaleString('id-ID')}\n\n`;
            response += `üìä *Data Summary:*\n`;
            response += `‚Ä¢ Total Transaksi: ${metadata.totalTransactions}\n`;
            response += `‚Ä¢ Total Pemasukan: Rp ${this.formatCurrency(metadata.totalIncome)}\n`;
            response += `‚Ä¢ Total Pengeluaran: Rp ${this.formatCurrency(metadata.totalExpense)}\n\n`;
            response += `üí° *Tips:*\n`;
            response += `‚Ä¢ File backup tersimpan di server\n`;
            response += `‚Ä¢ Ketik "backup list" untuk melihat daftar backup\n`;
            response += `‚Ä¢ Ketik "restore" untuk memulihkan data`;

            return response;

        } catch (error) {
            console.error('Error creating manual backup:', error);
            return '‚ùå Maaf, terjadi kesalahan saat membuat backup.';
        }
    }

    async handleBackupList() {
        try {
            const backupList = await this.backupService.getBackupList();
            
            if (backupList.length === 0) {
                return `üì¶ *DAFTAR BACKUP*\n\nBelum ada file backup yang tersimpan.\n\nüí° *Tips:*\n‚Ä¢ Ketik "backup" untuk membuat backup manual`;
            }

            let response = `üì¶ *DAFTAR BACKUP*\n\n`;
            
            backupList.slice(0, 10).forEach((backup, index) => {
                const date = new Date(backup.created).toLocaleString('id-ID');
                response += `${index + 1}. *${backup.fileName}*\n`;
                response += `   üìÖ ${date}\n`;
                response += `   üìè ${backup.sizeFormatted}\n\n`;
            });

            if (backupList.length > 10) {
                response += `... dan ${backupList.length - 10} file lainnya\n\n`;
            }

            response += `üí° *Tips:*\n`;
            response += `‚Ä¢ Total ${backupList.length} file backup\n`;
            response += `‚Ä¢ File terbaru di atas\n`;
            response += `‚Ä¢ Ketik "restore" untuk memulihkan data`;

            return response;

        } catch (error) {
            console.error('Error getting backup list:', error);
            return '‚ùå Maaf, terjadi kesalahan saat mengambil daftar backup.';
        }
    }

    async handleBackupSchedule() {
        try {
            if (!this.scheduledBackupService) {
                return '‚ùå *ERROR:* Scheduled backup service tidak tersedia.';
            }
            const schedules = this.scheduledBackupService.getSchedules();
            
            let response = `üïê *JADWAL BACKUP OTOMATIS*\n\n`;
            
            schedules.forEach(schedule => {
                const status = schedule.targetGroup ? 'üü¢ AKTIF' : 'üî¥ NONAKTIF';
                const nextRun = schedule.nextRun ? new Date(schedule.nextRun).toLocaleString('id-ID') : 'Tidak dijadwalkan';
                const targetGroup = schedule.targetGroup ? '‚úÖ Set' : '‚ùå Belum set';
                
                response += `üìÖ *${schedule.name}*\n`;
                response += `‚Ä¢ Status: ${status}\n`;
                response += `‚Ä¢ Jadwal: ${schedule.schedule}\n`;
                response += `‚Ä¢ Next Run: ${nextRun}\n`;
                response += `‚Ä¢ Target Group: ${targetGroup}\n\n`;
            });

            response += `üí° *Tips:*\n`;
            response += `‚Ä¢ Backup otomatis akan dikirim ke group\n`;
            response += `‚Ä¢ Set target group untuk mengaktifkan\n`;
            response += `‚Ä¢ File backup akan terlampir otomatis`;

            return response;

        } catch (error) {
            console.error('Error getting backup schedule:', error);
            return '‚ùå Maaf, terjadi kesalahan saat mengambil jadwal backup.';
        }
    }

    async handleRestoreBackup() {
        try {
            let response = `üîÑ *RESTORE BACKUP*\n\n`;
            response += `üìù *Cara Restore:*\n`;
            response += `1. Kirim file backup (.zip) ke chat ini\n`;
            response += `2. Bot akan memvalidasi file backup\n`;
            response += `3. Data akan dipulihkan otomatis\n\n`;
            response += `‚ö†Ô∏è *PERINGATAN:*\n`;
            response += `‚Ä¢ Data saat ini akan dihapus\n`;
            response += `‚Ä¢ Pastikan backup file valid\n`;
            response += `‚Ä¢ Proses tidak dapat dibatalkan\n\n`;
            response += `üí° *Tips:*\n`;
            response += `‚Ä¢ Ketik "backup list" untuk melihat daftar backup\n`;
            response += `‚Ä¢ File backup harus berformat .zip\n`;
            response += `‚Ä¢ Tunggu konfirmasi sebelum restore`;
            return response;

        } catch (error) {
            console.error('Error handling restore backup:', error);
            return '‚ùå Maaf, terjadi kesalahan saat memproses restore backup.';
        }
    }

    async handleRestoreConfirm() {
        try {
            // This will be handled by the server
            return 'üîÑ *RESTORE CONFIRMED*\n\nProses restore sedang berjalan...\n\n‚ö†Ô∏è *PERINGATAN:*\n‚Ä¢ Data saat ini akan dihapus\n‚Ä¢ Proses tidak dapat dibatalkan\n‚Ä¢ Tunggu konfirmasi selesai';
        } catch (error) {
            console.error('Error handling restore confirm:', error);
            return '‚ùå Maaf, terjadi kesalahan saat memproses restore confirm.';
        }
    }

    async handleRestoreCancel() {
        try {
            // This will be handled by the server
            return '‚ùå *RESTORE DIBATALKAN*\n\nProses restore telah dibatalkan.\n\nüí° *Tips:*\n‚Ä¢ File backup tetap tersimpan\n‚Ä¢ Ketik "restore" untuk mencoba lagi\n‚Ä¢ Ketik "backup list" untuk melihat daftar backup';
        } catch (error) {
            console.error('Error handling restore cancel:', error);
            return '‚ùå Maaf, terjadi kesalahan saat memproses restore cancel.';
        }
    }

    async handleDownloadBackup(message) {
        try {
            // Extract backup file name from message
            const parts = message.split(' ');
            let fileName = null;
            
            // Find backup file name in the message
            for (let i = 0; i < parts.length; i++) {
                if (parts[i].includes('.zip')) {
                    fileName = parts[i];
                    break;
                }
            }
            
            if (!fileName) {
                let response = `‚ùå *ERROR:* Nama file backup tidak ditemukan!\n\n`;
                response += `üìù *CARA PENGGUNAAN:*\n`;
                response += `‚Ä¢ Ketik: "download backup [nama_file.zip]"\n`;
                response += `‚Ä¢ Contoh: "download backup finance-backup-2025-01-28T10-30-00-000Z.zip"\n\n`;
                response += `üí° *TIPS:*\n`;
                response += `‚Ä¢ Ketik "backup list" untuk melihat daftar backup\n`;
                response += `‚Ä¢ File backup harus berformat .zip\n`;
                response += `‚Ä¢ Bot akan mengirim file backup ke chat`;
                return response;
            }
            
            // Check if file exists
            const backupList = await this.backupService.getBackupList();
            const backupFile = backupList.find(backup => backup.fileName === fileName);
            
            if (!backupFile) {
                let response = `‚ùå *ERROR:* File backup "${fileName}" tidak ditemukan!\n\n`;
                response += `üìù *DAFTAR BACKUP YANG TERSEDIA:*\n`;
                backupList.slice(0, 5).forEach((backup, index) => {
                    response += `${index + 1}. ${backup.fileName}\n`;
                });
                response += `\nüí° *TIPS:*\n`;
                response += `‚Ä¢ Ketik "backup list" untuk daftar lengkap\n`;
                response += `‚Ä¢ Pastikan nama file benar\n`;
                response += `‚Ä¢ File backup harus ada di server`;
                return response;
            }
            
            // Return success message with file info for server to send
            let response = `‚úÖ *DOWNLOAD BACKUP*\n\n`;
            response += `üì¶ *File:* ${fileName}\n`;
            response += `üìÖ *Created:* ${new Date(backupFile.created).toLocaleString('id-ID')}\n`;
            response += `üìè *Size:* ${backupFile.sizeFormatted}\n\n`;
            response += `üì§ *Status:* File sedang dikirim...\n\n`;
            response += `üí° *TIPS:*\n`;
            response += `‚Ä¢ File backup akan dikirim ke chat ini\n`;
            response += `‚Ä¢ Simpan file untuk restore nanti\n`;
            response += `‚Ä¢ File berformat .zip\n\n`;
            response += `üîß *File Info:* ${backupFile.filePath}`;
            return response;

        } catch (error) {
            console.error('Error handling download backup:', error);
            return '‚ùå Maaf, terjadi kesalahan saat memproses download backup.';
        }
    }

    async handleSendBackupFile(message) {
        try {
            // Extract backup file name from message
            const parts = message.split(' ');
            let fileName = null;
            
            // Find backup file name in the message
            for (let i = 0; i < parts.length; i++) {
                if (parts[i].includes('.zip')) {
                    fileName = parts[i];
                    break;
                }
            }
            
            if (!fileName) {
                let response = `‚ùå *ERROR:* Nama file backup tidak ditemukan!\n\n`;
                response += `üìù *CARA PENGGUNAAN:*\n`;
                response += `‚Ä¢ Ketik: "send backup [nama_file.zip]"\n`;
                response += `‚Ä¢ Contoh: "send backup finance-backup-2025-01-28T10-30-00-000Z.zip"\n\n`;
                response += `üí° *TIPS:*\n`;
                response += `‚Ä¢ Ketik "backup list" untuk melihat daftar backup\n`;
                response += `‚Ä¢ File backup harus berformat .zip\n`;
                response += `‚Ä¢ Bot akan mengirim file backup ke chat`;
                return response;
            }
            
            // Check if file exists
            const backupList = await this.backupService.getBackupList();
            const backupFile = backupList.find(backup => backup.fileName === fileName);
            
            if (!backupFile) {
                let response = `‚ùå *ERROR:* File backup "${fileName}" tidak ditemukan!\n\n`;
                response += `üìù *DAFTAR BACKUP YANG TERSEDIA:*\n`;
                backupList.slice(0, 5).forEach((backup, index) => {
                    response += `${index + 1}. ${backup.fileName}\n`;
                });
                response += `\nüí° *TIPS:*\n`;
                response += `‚Ä¢ Ketik "backup list" untuk daftar lengkap\n`;
                response += `‚Ä¢ Pastikan nama file benar\n`;
                response += `‚Ä¢ File backup harus ada di server`;
                return response;
            }
            
            // Return file info for server to send
            let response = `üì§ *SEND BACKUP FILE*\n\n`;
            response += `üì¶ *File:* ${fileName}\n`;
            response += `üìÖ *Created:* ${new Date(backupFile.created).toLocaleString('id-ID')}\n`;
            response += `üìè *Size:* ${backupFile.sizeFormatted}\n`;
            response += `üìÅ *Path:* ${backupFile.filePath}\n\n`;
            response += `üì§ *Status:* File sedang dikirim...\n\n`;
            response += `üí° *TIPS:*\n`;
            response += `‚Ä¢ File backup akan dikirim ke chat ini\n`;
            response += `‚Ä¢ Simpan file untuk restore nanti\n`;
            response += `‚Ä¢ File berformat .zip`;

            return response;

        } catch (error) {
            console.error('Error handling send backup file:', error);
            return '‚ùå Maaf, terjadi kesalahan saat memproses send backup file.';
        }
    }

    async handleSetBackupGroup(message) {
        try {
            if (!this.scheduledBackupService) {
                return '‚ùå *ERROR:* Scheduled backup service tidak tersedia.';
            }
            // Extract group ID from message
            const parts = message.split(' ');
            let groupId = null;
            let scheduleId = 'daily'; // Default to daily
            
            // Find group ID and schedule type in the message
            for (let i = 0; i < parts.length; i++) {
                if (parts[i].includes('@g.us')) {
                    groupId = parts[i];
                }
                if (parts[i] === 'daily' || parts[i] === 'weekly' || parts[i] === 'monthly') {
                    scheduleId = parts[i];
                }
            }
            
            if (!groupId) {
                let response = `‚ùå *ERROR:* Group ID tidak ditemukan!\n\n`;
                response += `üìù *CARA PENGGUNAAN:*\n`;
                response += `‚Ä¢ Ketik: "set backup group [group_id] [schedule]"\n`;
                response += `‚Ä¢ Contoh: "set backup group 123456789@g.us daily"\n`;
                response += `‚Ä¢ Schedule: daily, weekly, monthly\n\n`;
                response += `üí° *TIPS:*\n`;
                response += `‚Ä¢ Group ID harus berformat: [number]@g.us\n`;
                response += `‚Ä¢ Backup akan dikirim ke group secara otomatis\n`;
                response += `‚Ä¢ File backup akan terlampir otomatis`;
                return response;
            }
            
            // Validate group ID format
            if (!groupId.match(/^\d+@g\.us$/)) {
                let response = `‚ùå *ERROR:* Format Group ID tidak valid!\n\n`;
                response += `üìù *FORMAT YANG BENAR:*\n`;
                response += `‚Ä¢ Contoh: 123456789@g.us\n`;
                response += `‚Ä¢ Harus berakhir dengan @g.us\n`;
                response += `‚Ä¢ Hanya angka sebelum @g.us`;
                return response;
            }
            
            // Set target group for scheduled backup
            const result = this.scheduledBackupService.setTargetGroup(scheduleId, groupId);
            
            if (result.success) {
                let response = `‚úÖ *BACKUP GROUP SET*\n\n`;
                response += `üì¶ *Schedule:* ${scheduleId.toUpperCase()}\n`;
                response += `üë• *Target Group:* ${groupId}\n`;
                response += `üìÖ *Status:* Backup otomatis aktif\n\n`;
                response += `üí° *INFO:*\n`;
                response += `‚Ä¢ Backup akan dikirim ke group secara otomatis\n`;
                response += `‚Ä¢ File backup akan terlampir otomatis\n`;
                response += `‚Ä¢ Ketik "backup schedule" untuk cek jadwal`;
                return response;
            } else {
                return `‚ùå *ERROR:* ${result.error}`;
            }

        } catch (error) {
            console.error('Error handling set backup group:', error);
            return '‚ùå Maaf, terjadi kesalahan saat mengatur backup group.';
        }
    }

    async handleBackupGroupStatus() {
        try {
            if (!this.scheduledBackupService) {
                return '‚ùå *ERROR:* Scheduled backup service tidak tersedia.';
            }
            const schedules = this.scheduledBackupService.getSchedules();
            
            let response = `üì¶ *BACKUP GROUP STATUS*\n\n`;
            
            schedules.forEach(schedule => {
                const status = schedule.targetGroup ? '‚úÖ AKTIF' : '‚ùå NONAKTIF';
                const targetGroup = schedule.targetGroup || 'Belum diset';
                const nextRun = schedule.nextRun ? new Date(schedule.nextRun).toLocaleString('id-ID') : 'Tidak dijadwalkan';
                
                response += `üìÖ *${schedule.name}*\n`;
                response += `‚Ä¢ Status: ${status}\n`;
                response += `‚Ä¢ Target Group: ${targetGroup}\n`;
                response += `‚Ä¢ Next Run: ${nextRun}\n\n`;
            });

            response += `üí° *TIPS:*\n`;
            response += `‚Ä¢ Ketik "set backup group [group_id] [schedule]" untuk mengatur\n`;
            response += `‚Ä¢ Schedule: daily, weekly, monthly\n`;
            response += `‚Ä¢ File backup akan dikirim otomatis ke group`;

            return response;

        } catch (error) {
            console.error('Error handling backup group status:', error);
            return '‚ùå Maaf, terjadi kesalahan saat mengecek status backup group.';
        }
    }

    async generatePeriodReport(periodType) {
        try {
            const now = new Date();
            let startDate, endDate, periodName;
            console.log("generatePeriodReport", periodType);
            console.log("Current date:", now.toISOString());
            
            switch (periodType) {
                case 'current_month':
                    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                    periodName = 'BULAN INI';
                    break;
                    
                case 'last_month':
                    startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    endDate = new Date(now.getFullYear(), now.getMonth(), 0);
                    periodName = 'BULAN KEMARIN';
                    break;
                    
                case 'two_months_ago':
                    startDate = new Date(now.getFullYear(), now.getMonth() - 2, 1);
                    endDate = new Date(now.getFullYear(), now.getMonth() - 1, 0);
                    periodName = '2 BULAN YANG LALU';
                    break;
                    
                case 'three_months_ago':
                    startDate = new Date(now.getFullYear(), now.getMonth() - 3, 1);
                    endDate = new Date(now.getFullYear(), now.getMonth() - 2, 0);
                    periodName = '3 BULAN YANG LALU';
                    break;
                    
                case 'six_months_ago':
                    startDate = new Date(now.getFullYear(), now.getMonth() - 6, 1);
                    endDate = new Date(now.getFullYear(), now.getMonth() - 5, 0);
                    periodName = '6 BULAN YANG LALU';
                    break;
                    
                case 'one_year_ago':
                    startDate = new Date(now.getFullYear() - 1, now.getMonth(), 1);
                    endDate = new Date(now.getFullYear() - 1, now.getMonth() + 1, 0);
                    periodName = '1 TAHUN YANG LALU';
                    break;
                    
                default:
                    throw new Error('Invalid period type');
            }
            
            // Set time to start and end of day for consistency
            startDate.setHours(0, 0, 0, 0);
            endDate.setHours(23, 59, 59, 999);
            
            console.log(`Period: ${periodName}`);
            console.log(`Start date: ${startDate.toISOString()}`);
            console.log(`End date: ${endDate.toISOString()}`);
            console.log(`Start date string: ${startDate.toISOString().split('T')[0]}`);
            console.log(`End date string: ${endDate.toISOString().split('T')[0]}`);
            
            const report = await this.getDetailByDate(
                startDate.toISOString().split('T')[0],
                endDate.toISOString().split('T')[0]
            );
            
            let response = `üìÖ *LAPORAN ${periodName}*\n`;
            response += `üìÖ *BULAN ${startDate.toLocaleDateString('id-ID', { month: 'long', year: 'numeric' }).toUpperCase()}*\n\n`;
            
            // Summary section
            response += `üìä *RINGKASAN:*\n`;
            response += `üí∞ Total Pemasukan: Rp ${this.formatCurrency(report.summary.totalIncome)}\n`;
            response += `üí∏ Total Pengeluaran: Rp ${this.formatCurrency(report.summary.totalExpense)}\n`;
            response += `üí≥ Saldo: Rp ${this.formatCurrency(report.summary.totalIncome - report.summary.totalExpense)}\n`;
            response += `üìù Total Transaksi: ${report.summary.transactionCount}\n\n`;
            
            // Check if no transactions
            if (report.summary.transactionCount === 0) {
                response += `üìù *STATUS:* Belum ada transaksi ${periodName.toLowerCase()}\n\n`;
                response += `üí° *TIPS:*\n`;
                response += `‚Ä¢ Ketik transaksi keuangan untuk menambah data\n`;
                response += `‚Ä¢ Contoh: "jajan 50000" atau "gaji 5000000"\n`;
                response += `‚Ä¢ Ketik "bulan ini" untuk laporan bulanan\n\n`;
            }
            
            // Top categories
            if (Object.keys(report.expense.byCategory).length > 0) {
                response += `üèÜ *TOP 3 PENGELUARAN:*\n`;
                const sortedCategories = Object.keys(report.expense.byCategory)
                    .map(category => ({ category, ...report.expense.byCategory[category] }))
                    .sort((a, b) => b.total - a.total)
                    .slice(0, 3);
                
                sortedCategories.forEach((item, index) => {
                    response += `${index + 1}. ${item.category}: Rp ${this.formatCurrency(item.total)}\n`;
                });
                response += `\n`;
            }
            
            response += `üìÖ *Periode:* ${report.period.startDate} s/d ${report.period.endDate}\n`;
            response += `üí° *Tips:* Ketik "bulan ini" untuk laporan bulanan`;
            
            return response;
        } catch (error) {
            console.error(`Error generating ${periodType} report:`, error);
            return `‚ùå Maaf, terjadi kesalahan dalam membuat laporan ${periodType}.`;
        }
    }

    parseMonthYear(message) {
        const lowerMessage = message.toLowerCase().trim();
        
        // Mapping nama bulan Indonesia ke angka
        const monthMap = {
            'januari': 0, 'january': 0,
            'februari': 1, 'february': 1,
            'maret': 2, 'march': 2,
            'april': 3, 'april': 3,
            'mei': 4, 'may': 4,
            'juni': 5, 'june': 5,
            'juli': 6, 'july': 6,
            'agustus': 7, 'august': 7,
            'september': 8, 'september': 8,
            'oktober': 9, 'october': 9,
            'november': 10, 'november': 10,
            'desember': 11, 'december': 11
        };
        
        // Regex untuk mencocokkan "bulan tahun" atau "tahun bulan"
        const patterns = [
            /(\w+)\s+(\d{4})/, // "juni 2025" atau "june 2025"
            /(\d{4})\s+(\w+)/, // "2025 juni" atau "2025 june"
            /(\w+)\s+(\d{2})/, // "juni 25" atau "june 25"
            /(\d{2})\s+(\w+)/  // "25 juni" atau "25 june"
        ];
        
        for (const pattern of patterns) {
            const match = lowerMessage.match(pattern);
            if (match) {
                const monthName = match[1].toLowerCase();
                const yearStr = match[2];
                
                // Cek apakah match[1] adalah nama bulan
                if (monthMap[monthName]) {
                    let year = parseInt(yearStr);
                    
                    // Jika tahun 2 digit, konversi ke 4 digit
                    if (year < 100) {
                        year += 2000;
                    }
                    
                    return {
                        month: monthMap[monthName],
                        year: year,
                        monthName: monthName
                    };
                }
                
                // Cek apakah match[2] adalah nama bulan (untuk format "2025 juni")
                const monthName2 = match[2].toLowerCase();
                if (monthMap[monthName2]) {
                    let year = parseInt(match[1]);
                    
                    // Jika tahun 2 digit, konversi ke 4 digit
                    if (year < 100) {
                        year += 2000;
                    }
                    
                    return {
                        month: monthMap[monthName2],
                        year: year,
                        monthName: monthName2
                    };
                }
            }
        }
        
        return null;
    }

    async generateCustomMonthReport(month, year) {
        try {
            // Start of specified month (1st day)
            const startDate = new Date(year, month, 1);
            // End of specified month (last day)
            const endDate = new Date(year, month + 1, 0);
            
            const report = await this.getDetailByDate(
                startDate.toISOString().split('T')[0],
                endDate.toISOString().split('T')[0]
            );
            
            const monthNames = [
                'Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni',
                'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'
            ];
            
            let response = `üìÖ *LAPORAN BULAN ${monthNames[month].toUpperCase()} ${year}*\n\n`;
            
            // Summary section
            response += `üìä *RINGKASAN:*\n`;
            response += `üí∞ Total Pemasukan: Rp ${this.formatCurrency(report.summary.totalIncome)}\n`;
            response += `üí∏ Total Pengeluaran: Rp ${this.formatCurrency(report.summary.totalExpense)}\n`;
            response += `üí≥ Saldo: Rp ${this.formatCurrency(report.summary.totalIncome - report.summary.totalExpense)}\n`;
            response += `üìù Total Transaksi: ${report.summary.transactionCount}\n\n`;
            
            // Check if no transactions
            if (report.summary.transactionCount === 0) {
                response += `üìù *STATUS:* Belum ada transaksi bulan ${monthNames[month]} ${year}\n\n`;
                response += `üí° *TIPS:*\n`;
                response += `‚Ä¢ Ketik transaksi keuangan untuk menambah data\n`;
                response += `‚Ä¢ Contoh: "jajan 50000" atau "gaji 5000000"\n`;
                response += `‚Ä¢ Ketik "bulan ini" untuk laporan bulanan\n\n`;
            }
            
            // Top categories
            if (Object.keys(report.expense.byCategory).length > 0) {
                response += `üèÜ *TOP 3 PENGELUARAN:*\n`;
                const sortedCategories = Object.keys(report.expense.byCategory)
                    .map(category => ({ category, ...report.expense.byCategory[category] }))
                    .sort((a, b) => b.total - a.total)
                    .slice(0, 3);
                
                sortedCategories.forEach((item, index) => {
                    response += `${index + 1}. ${item.category}: Rp ${this.formatCurrency(item.total)}\n`;
                });
                response += `\n`;
            }
            
            response += `üìÖ *Periode:* ${report.period.startDate} s/d ${report.period.endDate}\n`;
            response += `üí° *Tips:* Ketik "bulan ini" untuk laporan bulanan`;
            
            return response;
        } catch (error) {
            console.error(`Error generating custom month report:`, error);
            return `‚ùå Maaf, terjadi kesalahan dalam membuat laporan bulan ${month} ${year}.`;
        }
    }
}

module.exports = FinanceBot;